# 数据结构与算法分析-JAVA语言描述

数据结构与算法分析-JAVA语言描述 原书超清第3版 下载

> 链接：https://pan.baidu.com/s/1DPxP0EnufMc_8i75jfiJjA   提取码：jqh6
>
> 转自 [数据结构与算法分析Java语言描述 原书超清第3版 下载_gulang0309的专栏-CSDN博客_数据结构与算法分析java语言描述](https://blog.csdn.net/gulang0309/article/details/88657633)

## 1.引论

### 1.1递归

#### 1.1.1递归的四条基本法则

- **基准情形**：必须总要有某些基准情形，它无需递归就能解出。
- **不断推进**：对于那些需要递归求解的情形，每一次递归调用都必须要使状况朝向一种基准情形推进。
- **设计法则**：假设所有的递归调用都能运行。
- **合成效益法则**：在求解一个问题的同一实例时，切勿在不同的递归调用中做重复性的工作。

#### 1.1.2递归实例

**（1）使用递归实现依次打印一个整数的每一位**

```java
    public static void printDigit(int a){
        System.out.println(a);
    }
	public static void printOut(int n){
        if (n>=10) printOut(n/10);
        printDigit(n%10);
    }
```

​		以printOut（987）为例，判断987大于10，求printOut（98），判断98大于10，求printOut(9)，判断9不大于10，输出9之后printOut（9）结束返回printOut（98）输出8之后printOut（98）结束，返回printOut（987）输出7，执行完毕。

### 1.2泛型

## 2.算法分析

### 2.1时间频度

​	时间频度：一个算法花费的时间与算法中语句的执行次数成正比例，哪个算法中语句执行次数多，它花费时间就多。一个算法中的语句执行次数称为语句频度或时间频度。记为 T(n).

### 2.2时间复杂度

​	一般情况下，算法中的基本操作语句的重复执行次数是问题规模 n 的某个函数，用 T(n)表示，若有某个辅助函数 f(n)，使得当 n 趋近于无穷大时，T(n) / f(n) 的极限值为不等于零的常数，则称 f(n)是T(n)的同数量级函数。记作 T(n)=Ｏ( f(n) )，称Ｏ( f(n) ) 为算法的渐进时间复杂度，简称时间复杂度。 

​	 T(n) 不同，但时间复杂度可能相同。 如：T(n)=n²+7n+6 与 T(n)=3n²+2n+2 它们的 T(n) 不同，但时间复杂 度相同，都为 O(n²)。 

​	 计算时间复杂度的方法： 

- 用常数 1 代替运行时间中的所有加法常数 T(n)=n²+7n+6 => T(n)=n²+7n+1 

- 修改后的运行次数函数中，只保留最高阶项 T(n)=n²+7n+1 => T(n) = n² 

- 去除最高阶项的系数 

### 2.3常见的时间复杂度

**常数阶 O(1)**

无论代码执行了多少行，只要是没有循环等复杂结构，那这个代码的时间复杂度就都是O(1)

![常熟阶](算法\常熟阶.png)

上述代码在执行的时候，它消耗的时候并不随着某个变量的增长而增长，那么无论这类代码有多长，即使有几万几十万行，都可以用O(1)来表示它的时间复杂度。

**对数阶 O(log2n)** 

![对数阶](算法\对数阶.png)

说明：在while循环里面，每次都将 i 乘以 2，乘完之后，i 距离 n 就越来越近了。假设循环x次之后，i 就大于 2 了，此时这个循环就退出了，也就是说 2 的 x 次方等于 n，那么 x = log2n也就是说当循环 log2n 次以后，这个代码就结束了。因此这个代码的时间复杂度为：O(log2n)  。 O(log2n) 的这个2 时间上是根据代码变化的，i = i * 3 ，则是 O(log3n) .

**线性阶 O(n)**

![图片1](算法\图片1.png)

说明：这段代码，for循环里面的代码会执行n遍，因此它消耗的时间是随着n的变化而变化的，因此这类代码都可以用O(n)来表示它的时间复杂度

**线性对数阶 O(nlog2n）**

![图片2](算法\图片2.png)

说明：线性对数阶O(nlogN) 其实非常容易理解，将时间复杂度为O(logn)的代码循环N遍的话，那么它的时间复杂度就是 n * O(logN)，也就是了O(nlogN)

**平方阶 O(n^2)** 

![图片3](算法\图片3.png)

说明：平方阶O(n²) 就更容易理解了，如果把 O(n) 的代码再嵌套循环一遍，它的时间复杂度就是 O(n²)，这段代码其实就是嵌套了2层n循环，它的时间复杂度就是 O(n*n)，即  O(n²) 如果将其中一层循环的n改成m，那它的时间复杂度就变成了 O(m*n)

**立方阶 O(n^3) ，k 次方阶 O(n^k) ，指数阶 O(2^n)**

说明：参考上面的O(n²) 去理解就好了，O(n³)相当于三层n循环，其它的类似

### 2.4平均时间复杂度和最坏时间复杂度

1) 平均时间复杂度是指所有可能的输入实例均以等概率出现的情况下，该算法的运行时间。
2) 最坏情况下的时间复杂度称最坏时间复杂度。一般讨论的时间复杂度均是最坏情况下的时间复杂度。这样做的
原因是：最坏情况下的时间复杂度是算法在任何输入实例上运行时间的界限，这就保证了算法的运行时间不会
比最坏情况更长。
3) 平均时间复杂度和最坏时间复杂度是否一致，和算法有关(如图:)。

![图片4](算法\图片4.png)

### 2.5空间复杂度

​	类似于时间复杂度的讨论，一个算法的空间复杂度(Space Complexity)定义为该算法所耗费的存储空间，它也是 问题规模 n 的函数。

​	空间复杂度(Space Complexity)是对一个算法在运行过程中临时占用存储空间大小的量度。有的算法需要占用的 临时工作单元数与解决问题的规模 n 有关，它随着 n 的增大而增大，当 n 较大时，将占用较多的存储单元，例 如快速排序和归并排序算法, 基数排序就属于这种情况

​	在做算法分析时，主要讨论的是时间复杂度。从用户使用体验上看，更看重的程序执行的速度。一些缓存产品 (redis, memcache)和算法(基数排序)本质就是用空间换时间.

## 3.数据结构概述

### 3.1线性结构

​	<u>线性结构作为最常用的数据结构，其特点是数据元素之间存在一对一的线性关系</u> 

​	线性结构有两种不同的存储结构，即顺序存储结构(**数组**)和链式存储结构(**链表**)。顺序存储的线性表称为顺序表，顺序表中的存储元素是连续的；链式存储的线性表称为链表，链表中的存储元素不一定是连续的，元素节点中存放数据元素以及相邻元素的地址信息。

​	线性结构常见的有：**数组、队列、链表和栈**

### 3.2非线性结构

非线性结构包括：**二维数组，多维数组，广义表，树结构，图结**

## 4.稀疏数组和队列

### 4.1稀缺数组（SparseArray）

当一个数组中大部分元素为０，或者为同一个值的数组时，可以使用稀疏数组来保存该数组。 

稀疏数组的处理方法是: 

1) 记录数组一共有几行几列，有多少个不同的值 
2) 把具有不同值的元素的行列及值记录在一个小规模的数组中，从而缩小程序的规模

![屏幕截图 2021-08-16 195958](算法\稀缺数组.png)

### 4.2队列

队列是一个有序列表，可以用数组或是链表来实现。 

遵循先入先出的原则。即：先存入队列的数据，要先取出。后存入的要后取出

### 4.2.1数组模拟队列

队列本身是有序列表，若使用数组的结构来存储队列的数据，则队列数组的声明如下图, 其中 maxSize 是该队列的最大容量。 

 因为队列的输出、输入是分别从前后端来处理，因此需要两个变量 front 及 rear 分别记录队列前后端的下标， front 会随着数据输出而改变，而 rear 则是随着数据输入而改变。

![数组实现队列](算法\数组实现队列.png)

```java
class ArrayQueue{
    private int maxSize;    //队列的最大长度
    private int front;      //队列头下标，指向队列头的前一个位置，初始为-1
    private int rear;       //队列的尾下标，指向队列尾的数据，初始为-1
    private int arr[];      //存放数据，模拟队列
}
```

**问题分析**：目前数组使用一次就不能用， 没有达到复用。

**优化**：将这个数组使用算法，改进成一个环形的队列。

### 4.2.2数组模拟环形队列

![数组实现环形队列](算法\数组实现环形队列.png)

```java
class CircleArrayQueue{
    private int maxSize;    //队列的最大长度，队列的有效长度为maxSize-1，空出一个空间
    private int front;      //队列头下标，指向队列的第一个数据，初始值为0
    private int rear;       //队列的尾下标，指向队列最后一个数据的后面一位，初始值为0
    private int arr[];      //存放数据，模拟队列
}
```

## 5.链表

### 5.1链表介绍

链表是有序的列表，但是它在内存中是存储如下

![单链表](算法/单链表.png)

链表是以节点的方式来存储,是链式存储 

每个节点包含 data 域， next 域：指向下一个节点. 

如图：发现链表的各个节点不一定是连续存储.

链表分带头节点的链表和没有头节点的链表，根据实际的需求来确定

### 5.2单链表的应用实例

使用带 head 头的单向链表实现 –水浒英雄排行榜管理完成对英雄人物的增删改查操作

```java
//定义英雄节点
class HeroNode{
    public int no;          //编号
    public String name;     //名称
    public String nickName; //外号
    public HeroNode next;   //指向下一个节点的指针
}

//定义单链表
class SingleLinkedList{
    //初始化头节点
    private HeroNode head  = new HeroNode(0,"","");
}
```

#### 5.2.1增删改节点

- 添加节点

![添加节点](算法\添加节点.png)

- 根据排名添加节点

![根据排名添加节点](算法\根据排名添加节点.png)

- 删除和修改同理

#### 5.2.2复杂功能

- 求单链表中有效节点的个数

```java
    public int getLength(HeroNode head){
        int length =0;
        while (head.next!=null){
            length++;
            head = head.next;
        }
        return length;
    }
```

- 查找单链表中的倒数第 k 个结点

```java
//***使用快慢指针一次遍历实现查找链表的倒数第n个节点***
public HeroNode findLastIndexNode(HeroNode head,int n){
    if (head.next==null)
        throw new RuntimeException("链表为空!!!");
     HeroNode fast = head.next;
     HeroNode slow = head.next;
     while (fast.next!=null){
         //快指针先移动
         fast = fast.next;
         if (n!=1)
             n--;
         else
             //当快指针移动了n次时，代表快慢指针相隔n，慢指针可以开始移动，此时当快指针移动到链表的尾部时，慢指针指向的是链表倒数第n个节点
             slow = slow.next;
         //当快指针已经到达链表尾部时，快慢指针相隔任然小于n，说明n小于了链表的长度
         if (fast.next==null&&n>1)
             throw new RuntimeException("n大于了链表的长度!!!");
     }
     return slow;
}
```

- 单链表的反转

![反转链表](算法\反转链表.png)

```java
//头插法实现链表的逆转
public void reversetList(HeroNode head){
    if (head.next==null||head.next.next==null)
        throw new RuntimeException("链表为空!!!");
    //将原来链表上面的节点依次插到该链表后
    HeroNode revHead = new HeroNode(0, "", "");
    HeroNode temp;
    while (head.next!=null){
        temp = head.next.next;          //temp用来保存与那链表的第二个节点，以防止数据丢失
        head.next.next=revHead.next;    //将原链表的第一个节点的next指向反转链表的第一个节点
        revHead.next = head.next;       //将反转链表的头结点的next指向原链表的第一个节点
        head.next = temp;               //原链表的第一个节点此时已经转移为了反转链表的第一个节点，将原链表的第二个节点作为原链表的第一个节点
    }
    //此处不能head = revHead 因为函数结束之后，revHead作为局部变量会失效
    head.next = revHead.next;
}
```

- 从尾到头打印单链表 

```java
//递归实现逆序打印链表内容
public void reversePrint1(HeroNode head){
    if(head.next == null) {
        return;//空链表，不能打印
    }
    //当head.next指向链表尾节点时递归结束
    if (head.next.next==null)
        System.out.println(head.next);
    else{
        reversePrint1(head.next);
        System.out.println(head.next);
    }
}

//使用栈Stack逆序打印链表内容
public void reversePrint2(HeroNode head){
    if(head.next == null) {
        return;//空链表，不能打印
    }
    //创建要给一个栈，将各个节点压入栈
    Stack<HeroNode> stack = new Stack<HeroNode>();
    HeroNode cur = head.next;
    //将链表的所有节点压入栈
    while(cur != null) {
        stack.push(cur);
        cur = cur.next; //cur 后移，这样就可以压入下一个节点
    }
    //将栈中的节点进行打印,pop 出栈
    while (stack.size() > 0) {
        System.out.println(stack.pop()); //stack 的特点是先进后出
    }
}
```

### 5.3双向链表

**单向链表的缺点分析**: 

- 单向链表，查找的方向只能是一个方向，而双向链表可以向前或者向后查找。 
- 单向链表不能自我删除，需要靠辅助节点 ，而双向链表，则可以自我删除，所以前面我们单链表删除 时节点，总是找到 temp,temp 是待删除节点的前一个节点(认真体会）

**代码实现**

```java
class HeroNode2 {
public int no;
public String name;
public String nickname;
public HeroNode2 next; // 指向下一个节点, 默认为 null
public HeroNode2 pre; // 指向前一个节点, 默认为 null
}
```

### 5.4环形链表-约瑟夫问题

#### 5.4.1约瑟夫问题

Josephu(约瑟夫、约瑟夫环) 问题为：设编号为 1，2，… n 的 n 个人围坐一圈，约定编号为 k（1<=k<=n）的人从 1 开始报数，数 到 m 的那个人出列，它的下一位又从 1 开始报数，数到 m 的那个人又出列，依次类推，直到所有人出列为止，由 此产生一个出队编号的序列。

#### 5.4.2解决思路

用一个不带头结点的循环链表来处理 Josephu 问题：先构成一个有 n 个结点的单循环链表，然后由 k 结点起从 1 开 始计数，计到 m 时，对应结点从链表中删除，然后再从被删除结点的下一个结点又从 1 开始计数，直到最后一个 尚硅谷 Java 数据结构和算法 更多 Java –大数据 –前端 –python 人工智能 -区块链资料下载，可访问百度：尚硅谷官网 第 55页 结点从链表中删除算法结束。

![约瑟夫问题思路分析](算法/约瑟夫问题思路分析.png)

#### 5.4.3代码实现

```java
// 创建一个 Boy 类，表示一个节点
class Boy {
    private int no;// 编号
    private Boy next; // 指向下一个节点,默认 null
}
// 根据用户的输入，计算出小孩出圈的顺序
/**
     *
     * @param startNo
     * 表示从第几个小孩开始数数
     * @param countNum
     * 表示数几下
     * @param nums
     * 表示最初有多少小孩在圈中
     */
public void countBoy(int startNo, int countNum, int nums) {

    if (nums<1||countNum<1||first==null||startNo<1||startNo>nums)
        throw new RuntimeException("参数有误，从新输入！！");
    //创建辅助指针，指向环形链表的最后一个节点
    Boy helper = first;
    while (helper.getNext()!=first){
        helper = helper.getNext();
    }
    //移动helper和first，使从第startNo个小孩开始数
    for (int i=0;i<(startNo-1);i++){
        helper = helper.getNext();
        first = first.getNext();
    }
    //开始数数，出圈
    while (helper!=first){
        //报数
        for (int i=0;i<(countNum-1);i++){
            helper = helper.getNext();
            first = first.getNext();
        }
        System.out.println("小孩"+ first.getNo() +"出队列：" );
        first = first.getNext();
        helper.setNext(first);

    }
    System.out.println("最后的小孩："+ first.getNo());
}
```

## 6.栈

### 6.1栈的介绍

- 栈的英文为(stack) 
- 栈是一个先入后出(FILO-First In Last Out)的有序列表。
- 栈(stack)是限制线性表中元素的插入和删除只能在线性表的同一端进行的一种特殊线性表。允许插入和删除的 一端，为变化的一端，称为栈顶(Top)，另一端为固定的一端，称为栈底(Bottom)。
- 根据栈的定义可知，最先放入栈中元素在栈底，最后放入的元素在栈顶，而删除元素刚好相反，最后放入的元 素最先删除，最先放入的元素最后删除 
- 图解方式说明出栈(pop)和入栈(push)的概念

![栈的介绍](算法/栈的介绍.png)

**应用场景**

1) 子程序的调用：在跳往子程序前，会先将下个指令的地址存到堆栈中，直到子程序执行完后再将地址取出，以回到原来的程序中。 
2) 处理递归调用：和子程序的调用类似，只是除了储存下一个指令的地址外，也将参数、区域变量等数据存入堆栈中。 
3) 表达式的转换[中缀表达式转后缀表达式]与求值(实际解决)。
4) 二叉树的遍历。 
5) 图形的深度优(depth 一 first)搜索法。

### 6.2数组实现栈

##### ![数组模拟栈](算法/数组模拟栈.png)

```java
class ArrayStack{
    private int maxSize;
    private int[] stack;
    private int top;
    public ArrayStack(int maxSize) {
        this.maxSize = maxSize;
        stack = new int[maxSize];
        top = -1;
    }
    public boolean isFull(){return top==maxSize-1;}
    public boolean isEmpty(){return top ==-1;}
    //入栈
    public void push(int value){
        if (isFull())
            throw new RuntimeException("栈满！！！");
        top++;
        stack[top] = value;
    }
    //出栈
    public int pop(){
        if (isEmpty())
            throw new RuntimeException("栈空！！！");
        top--;
        return stack[top+1];
    }
    //从栈顶开始输出栈内的数据
    public void list(){
        for (int i=top;i>=0;i--)
            System.out.printf("stack[%d]=%d\n", i, stack[i]);
    }
}
```

### 6.3栈实现综合计算器(中缀表达式)

![栈实现综合计算器(中缀表达式)](算法/栈实现综合计算器(中缀表达式).png)

**具体代码见 package com.yue.stack.Calculator**

## 7.递归

## 8.排序算法

### 8.1排序算法介绍

- 内部排序: 指将需要处理的所有数据都加载到内部存储器(内存)中进行排序。 
- 外部排序法： 数据量过大，无法全部加载到内存中，需要借助外部存储(文件等)进行排序。

![排序算法](算法/排序算法.png)

### 8.2冒泡排序

**冒泡排序**（Bubble Sorting）的基本思想是：通过对待排序序列从前向后（从下标较小的元素开始）,依次比较 相邻元素的值，若发现逆序则交换，使值较大的元素逐渐从前移向后部，就像水底下的气泡一样逐渐向上冒。 

- 优化： 因为排序的过程中，各元素不断接近自己的位置，如果一趟比较下来没有进行过交换，就说明序列有序，因此要在 排序过程中设置一个标志 flag 判断元素是否进行过交换。从而减少不必要的比较。

![冒泡排序](算法/冒泡排序.png)

```java
//冒泡排序
public class BubbleSort {
    public static void main(String[] args) {
        int arr[]={3,9,-1,10,2};
        //提前将len储存好，防止每次for循环都要计算length浪费时间，使用空间换时间
        int len = arr.length;
        //标志位，优化冒泡排序
        boolean flag = false;

        //一共需要冒泡len-1次即可完成排序
        for(int i=0;i<len-1;i++){
            //因为上一次冒泡已经将前i为都固定到了正确的位置上，只需要将泡冒到len-1的位置即可
            for (int j=0;j<len-i-1;j++){
                if (arr[j]>arr[j+1]){
                    int temp = arr[j+1];
                    arr[j+1] = arr[j];
                    arr[j] = temp;
                    flag=true;
                }
            }
            //如果这一趟冒泡中没有发生位置交换，说明此时数组已经排序完成，退出循环即可
            if (!flag) break;
            flag = false;
            System.out.println(Arrays.toString(arr));
        }
    }
}
```

### 8.3选择排序

**选择排序**（select sorting）也是一种简单的排序方法。它的基本思想是：第一次从 arr[0]~arr[n-1]中选取最小值， 与 arr[0]交换，第二次从 arr[1]~arr[n-1]中选取最小值，与 arr[1]交换，第三次从 arr[2]~arr[n-1]中选取最小值，与 arr[2] 交换，…，第 i 次从 arr[i-1]~arr[n-1]中选取最小值，与 arr[i-1]交换，…, 第 n-1 次从 arr[n-2]~arr[n-1]中选取最小值， 与 arr[n-2]交换，总共通过 n-1 次，得到一个按排序码从小到大排列的有序序列

![选择排序](算法/选择排序.png)

```java
public class SelectSort {
    public static void main(String[] args) {
        int arr[]={3,9,-1,10,2};
        //提前将len储存好，防止每次for循环都要计算length浪费时间，使用空间换时间
        int len = arr.length;
        //选择len-1次即可完成排序
        for (int i=0;i<len-1;i++){
            //假如第i个为最大
            int maxIndex = i;
            //将arr[i]与后面的数据依次比较，寻找最小的值的下标
            for (int j=i;j<len;j++)
                if (arr[maxIndex]<arr[j])
                    maxIndex=j;
                //将最小值与第i个值交换位置
            int temp = arr[i];
            arr[i] = arr[maxIndex];
            arr[maxIndex] = temp;
        }
        System.out.println(Arrays.toString(arr));
    }
}
```

### 8.4插入排序

**插入排序**（Insertion Sorting）的基本思想是：把 n 个待排序的元素看成为一个有序表和一个无序表，开始时有 序表中只包含一个元素，无序表中包含有 n-1 个元素，排序过程中每次从无序表中取出第一个元素，把它的排 序码依次与有序表元素的排序码进行比较，将它插入到有序表中的适当位置，使之成为新的有序表。

![插入排序](算法/插入排序.png)

```java
public class InsertSort {
    public static void main(String[] args) {
        int arr[]={3,9,4,5,-2};
        //提前将len储存好，防止每次for循环都要计算length浪费时间，使用空间换时间
        int len = arr.length;

        //第一位只有一位数字，默认为其有序，从第二位开始
        for (int i=1;i<len;i++){
            int temp = arr[i];  //防止后面数组后移时数据丢失，提前创建中间变量储存数组
            int inserIndex = i-1;  //存放要插入的位置下标

            //在前面的有序部分寻找插入位置
            //insertIndex>=0让数组不越界，当inserIndex=-1时说名要将temp插入到0下标位置
            while(inserIndex>=0&&temp<arr[inserIndex]){
                arr[inserIndex+1] = arr[inserIndex];//将数组后移，腾出插入位置
                inserIndex--;
            }
            arr[inserIndex+1] = temp;
        }
        System.out.println(Arrays.toString(arr));
    }
}
```

### 8.4希尔排序

## 9.查找算法

## 10.哈希表

## 11.树结构

### 11.1为什么需要树这种数据结构

1) 数组存储方式的分析 优点：通过下标方式访问元素，速度快。对于有序数组，还可使用二分查找提高检索速度。 缺点：如果要检索具体某个值，或者插入值(按一定顺序)会整体移动，效率较低

![数组特点](算法/数组特点.png)

2) 链式存储方式的分析 优点：在一定程度上对数组存储方式有优化(比如：插入一个数值节点，只需要将插入节点，链接到链表中即可， 删除效率也很好)。 缺点：在进行检索时，效率仍然较低，比如(检索某个值，需要从头节点开始遍历) 

![链表特点](算法/链表特点.png)

3) 树存储方式的分析 能提高数据存储，读取的效率, 比如利用 二叉排序树(Binary Sort Tree)，既可以保证数据的检索速度，同时也 可以保证数据的插入，删除，修改的速度。

![树特点](算法/树特点.png)

### 11.2树的常用术语

树的常用术语(结合示意图理解): 

- 节点 
- 根节点
- 父节点 
- 子节点 
- 叶子节点 (没有子节点的节点)
- 节点的权(节点值) 
- 路径(从 root 节点找到该节点的路线) 
- 层 
- 子树
- 树的高度(最大层数) 
- 森林 :多颗子树构成森林

![树的专用术语](算法/树的专用术语.png)

### 11.3二叉树

- 树有很多种，每个节点最多只能有两个子节点的一种形式称为二叉树。 

- 二叉树的子节点分为左节点和右节点

![二叉树](算法/二叉树.png)

- 如果该二叉树的所有叶子节点都在最后一层，并且结点总数= 2^n -1 , n 为层数，则我们称为**满二叉树**

![满二叉树](算法/满二叉树.png)

- 如果该二叉树的所有叶子节点都在最后一层或者倒数第二层，而且最后一层的叶子节点在左边连续，倒数第二 层的叶子节点在右边连续，我们称为**完全二叉树**

![完全二叉树](算法/完全二叉树.png)

#### 11.3.2二叉树-遍历

前序遍历: 先输出父节点，再遍历左子树和右子树 

中序遍历: 先遍历左子树，再输出父节点，再遍历右子树 

后序遍历: 先遍历左子树，再遍历右子树，最后输出父节点

![二叉树的遍历](算法/二叉树的遍历.png)

```java
//树的节点
class HeroNode{
    private int no;
    private String name;
    private HeroNode left;  //左右节点
    private HeroNode right;
}
//前序遍历
public void preOrder(HeroNode node){
    if (node == null) throw new RuntimeException("树为空！！！");
    System.out.println(node.getNo());
    if (node.getLeft()!=null) preOrder(node.getLeft());
    if (node.getRight()!=null) preOrder(node.getRight());
}
//中序遍历
public void infixOrder(HeroNode node){
    if (node == null) throw new RuntimeException("树为空！！！");
    if (node.getLeft()!=null) infixOrder(node.getLeft());
    System.out.println(node.getNo());
    if (node.getRight()!=null) infixOrder(node.getRight());
}
//后序遍历
public void postOrder(HeroNode node){
    if (node == null) throw new RuntimeException("树为空！！！");
    if (node.getLeft()!=null) postOrder(node.getLeft());
    if (node.getRight()!=null) postOrder(node.getRight());
    System.out.println(node.getNo());
}
```

#### 11.3.3二叉树-查找指定节点

![二叉树查找](算法/二叉树查找.png)



```java
//前序遍历查找
public HeroNode preOrderSearch(HeroNode node,int no){
    if (node == null) throw new RuntimeException("树为空！！！");
    HeroNode resNode = null;    //假如查找到节点就放到resNode中，以方便判断递归的停止
    if (node.getNo()==no) return node;
    if (node.getLeft()!=null) resNode = preOrderSearch(node.getLeft(),no);
    if (resNode!=null) return resNode;  //在左分支上面查找到结果的话就结束递归，不在进入右分支
    if (node.getRight()!=null)resNode = preOrderSearch(node.getRight(),no);
    if (resNode!=null) return resNode;
    return null;
}
```



#### 11.3.4二叉树-删除指定节点

![二叉树删除节点](算法/二叉树删除节点.png)
