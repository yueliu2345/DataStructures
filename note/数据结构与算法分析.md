[toc]

数据结构与算法分析-JAVA语言描述

数据结构与算法分析-JAVA语言描述 原书超清第3版 下载

> 链接：https://pan.baidu.com/s/1DPxP0EnufMc_8i75jfiJjA   提取码：jqh6
>
> 转自 [数据结构与算法分析Java语言描述 原书超清第3版 下载_gulang0309的专栏-CSDN博客_数据结构与算法分析java语言描述](https://blog.csdn.net/gulang0309/article/details/88657633)

## 1.引论

### 1.1递归

#### 1.1.1递归的四条基本法则

- **基准情形**：必须总要有某些基准情形，它无需递归就能解出。
- **不断推进**：对于那些需要递归求解的情形，每一次递归调用都必须要使状况朝向一种基准情形推进。
- **设计法则**：假设所有的递归调用都能运行。
- **合成效益法则**：在求解一个问题的同一实例时，切勿在不同的递归调用中做重复性的工作。

#### 1.1.2递归实例

**（1）使用递归实现依次打印一个整数的每一位**

```java
    public static void printDigit(int a){
        System.out.println(a);
    }
	public static void printOut(int n){
        if (n>=10) printOut(n/10);
        printDigit(n%10);
    }
```

​		以printOut（987）为例，判断987大于10，求printOut（98），判断98大于10，求printOut(9)，判断9不大于10，输出9之后printOut（9）结束返回printOut（98）输出8之后printOut（98）结束，返回printOut（987）输出7，执行完毕。

### 1.2泛型

## 2.算法分析

### 2.1时间频度

​	时间频度：一个算法花费的时间与算法中语句的执行次数成正比例，哪个算法中语句执行次数多，它花费时间就多。一个算法中的语句执行次数称为语句频度或时间频度。记为 T(n).

### 2.2时间复杂度

​	一般情况下，算法中的基本操作语句的重复执行次数是问题规模 n 的某个函数，用 T(n)表示，若有某个辅助函数 f(n)，使得当 n 趋近于无穷大时，T(n) / f(n) 的极限值为不等于零的常数，则称 f(n)是T(n)的同数量级函数。记作 T(n)=Ｏ( f(n) )，称Ｏ( f(n) ) 为算法的渐进时间复杂度，简称时间复杂度。 

​	 T(n) 不同，但时间复杂度可能相同。 如：T(n)=n²+7n+6 与 T(n)=3n²+2n+2 它们的 T(n) 不同，但时间复杂 度相同，都为 O(n²)。 

​	 计算时间复杂度的方法： 

- 用常数 1 代替运行时间中的所有加法常数 T(n)=n²+7n+6 => T(n)=n²+7n+1 

- 修改后的运行次数函数中，只保留最高阶项 T(n)=n²+7n+1 => T(n) = n² 

- 去除最高阶项的系数 

### 2.3常见的时间复杂度

**常数阶 O(1)**

无论代码执行了多少行，只要是没有循环等复杂结构，那这个代码的时间复杂度就都是O(1)

![常熟阶](算法\常熟阶.png)

上述代码在执行的时候，它消耗的时候并不随着某个变量的增长而增长，那么无论这类代码有多长，即使有几万几十万行，都可以用O(1)来表示它的时间复杂度。

**对数阶 O(log2n)** 

![对数阶](算法\对数阶.png)

说明：在while循环里面，每次都将 i 乘以 2，乘完之后，i 距离 n 就越来越近了。假设循环x次之后，i 就大于 2 了，此时这个循环就退出了，也就是说 2 的 x 次方等于 n，那么 x = log2n也就是说当循环 log2n 次以后，这个代码就结束了。因此这个代码的时间复杂度为：O(log2n)  。 O(log2n) 的这个2 时间上是根据代码变化的，i = i * 3 ，则是 O(log3n) .

**线性阶 O(n)**

![图片1](算法\图片1.png)

说明：这段代码，for循环里面的代码会执行n遍，因此它消耗的时间是随着n的变化而变化的，因此这类代码都可以用O(n)来表示它的时间复杂度

**线性对数阶 O(nlog2n）**

![图片2](算法\图片2.png)

说明：线性对数阶O(nlogN) 其实非常容易理解，将时间复杂度为O(logn)的代码循环N遍的话，那么它的时间复杂度就是 n * O(logN)，也就是了O(nlogN)

**平方阶 O(n^2)** 

![图片3](算法\图片3.png)

说明：平方阶O(n²) 就更容易理解了，如果把 O(n) 的代码再嵌套循环一遍，它的时间复杂度就是 O(n²)，这段代码其实就是嵌套了2层n循环，它的时间复杂度就是 O(n*n)，即  O(n²) 如果将其中一层循环的n改成m，那它的时间复杂度就变成了 O(m*n)

**立方阶 O(n^3) ，k 次方阶 O(n^k) ，指数阶 O(2^n)**

说明：参考上面的O(n²) 去理解就好了，O(n³)相当于三层n循环，其它的类似

### 2.4平均时间复杂度和最坏时间复杂度

1) 平均时间复杂度是指所有可能的输入实例均以等概率出现的情况下，该算法的运行时间。
2) 最坏情况下的时间复杂度称最坏时间复杂度。一般讨论的时间复杂度均是最坏情况下的时间复杂度。这样做的
原因是：最坏情况下的时间复杂度是算法在任何输入实例上运行时间的界限，这就保证了算法的运行时间不会
比最坏情况更长。
3) 平均时间复杂度和最坏时间复杂度是否一致，和算法有关(如图:)。

![图片4](算法\图片4.png)

### 2.5空间复杂度

​	类似于时间复杂度的讨论，一个算法的空间复杂度(Space Complexity)定义为该算法所耗费的存储空间，它也是 问题规模 n 的函数。

​	空间复杂度(Space Complexity)是对一个算法在运行过程中临时占用存储空间大小的量度。有的算法需要占用的 临时工作单元数与解决问题的规模 n 有关，它随着 n 的增大而增大，当 n 较大时，将占用较多的存储单元，例 如快速排序和归并排序算法, 基数排序就属于这种情况

​	在做算法分析时，主要讨论的是时间复杂度。从用户使用体验上看，更看重的程序执行的速度。一些缓存产品 (redis, memcache)和算法(基数排序)本质就是用空间换时间.

## 3.数据结构概述

### 3.1线性结构

​	<u>线性结构作为最常用的数据结构，其特点是数据元素之间存在一对一的线性关系</u> 

​	线性结构有两种不同的存储结构，即顺序存储结构(**数组**)和链式存储结构(**链表**)。顺序存储的线性表称为顺序表，顺序表中的存储元素是连续的；链式存储的线性表称为链表，链表中的存储元素不一定是连续的，元素节点中存放数据元素以及相邻元素的地址信息。

​	线性结构常见的有：**数组、队列、链表和栈**

### 3.2非线性结构

非线性结构包括：**二维数组，多维数组，广义表，树结构，图结**

## 4.稀疏数组和队列

### 4.1稀缺数组（SparseArray）

当一个数组中大部分元素为０，或者为同一个值的数组时，可以使用稀疏数组来保存该数组。 

稀疏数组的处理方法是: 

1) 记录数组一共有几行几列，有多少个不同的值 
2) 把具有不同值的元素的行列及值记录在一个小规模的数组中，从而缩小程序的规模

![屏幕截图 2021-08-16 195958](算法\稀缺数组.png)

### 4.2队列

队列是一个有序列表，可以用数组或是链表来实现。 

遵循先入先出的原则。即：先存入队列的数据，要先取出。后存入的要后取出

### 4.2.1数组模拟队列

队列本身是有序列表，若使用数组的结构来存储队列的数据，则队列数组的声明如下图, 其中 maxSize 是该队列的最大容量。 

 因为队列的输出、输入是分别从前后端来处理，因此需要两个变量 front 及 rear 分别记录队列前后端的下标， front 会随着数据输出而改变，而 rear 则是随着数据输入而改变。

![数组实现队列](算法\数组实现队列.png)

```java
class ArrayQueue{
    private int maxSize;    //队列的最大长度
    private int front;      //队列头下标，指向队列头的前一个位置，初始为-1
    private int rear;       //队列的尾下标，指向队列尾的数据，初始为-1
    private int arr[];      //存放数据，模拟队列
}
```

**问题分析**：目前数组使用一次就不能用， 没有达到复用。

**优化**：将这个数组使用算法，改进成一个环形的队列。

### 4.2.2数组模拟环形队列

![数组实现环形队列](算法\数组实现环形队列.png)

```java
class CircleArrayQueue{
    private int maxSize;    //队列的最大长度，队列的有效长度为maxSize-1，空出一个空间
    private int front;      //队列头下标，指向队列的第一个数据，初始值为0
    private int rear;       //队列的尾下标，指向队列最后一个数据的后面一位，初始值为0
    private int arr[];      //存放数据，模拟队列
}
```

## 5.链表

### 5.1链表介绍

链表是有序的列表，但是它在内存中是存储如下

![单链表](算法/单链表.png)

链表是以节点的方式来存储,是链式存储 

每个节点包含 data 域， next 域：指向下一个节点. 

如图：发现链表的各个节点不一定是连续存储.

链表分带头节点的链表和没有头节点的链表，根据实际的需求来确定

### 5.2单链表的应用实例

使用带 head 头的单向链表实现 –水浒英雄排行榜管理完成对英雄人物的增删改查操作

```java
//定义英雄节点
class HeroNode{
    public int no;          //编号
    public String name;     //名称
    public String nickName; //外号
    public HeroNode next;   //指向下一个节点的指针
}

//定义单链表
class SingleLinkedList{
    //初始化头节点
    private HeroNode head  = new HeroNode(0,"","");
}
```

#### 5.2.1增删改节点

- 添加节点

![添加节点](算法\添加节点.png)

- 根据排名添加节点

![根据排名添加节点](算法\根据排名添加节点.png)

- 删除和修改同理

#### 5.2.2复杂功能

- 求单链表中有效节点的个数

```java
    public int getLength(HeroNode head){
        int length =0;
        while (head.next!=null){
            length++;
            head = head.next;
        }
        return length;
    }
```

- 查找单链表中的倒数第 k 个结点

```java
//***使用快慢指针一次遍历实现查找链表的倒数第n个节点***
public HeroNode findLastIndexNode(HeroNode head,int n){
    if (head.next==null)
        throw new RuntimeException("链表为空!!!");
     HeroNode fast = head.next;
     HeroNode slow = head.next;
     while (fast.next!=null){
         //快指针先移动
         fast = fast.next;
         if (n!=1)
             n--;
         else
             //当快指针移动了n次时，代表快慢指针相隔n，慢指针可以开始移动，此时当快指针移动到链表的尾部时，慢指针指向的是链表倒数第n个节点
             slow = slow.next;
         //当快指针已经到达链表尾部时，快慢指针相隔任然小于n，说明n小于了链表的长度
         if (fast.next==null&&n>1)
             throw new RuntimeException("n大于了链表的长度!!!");
     }
     return slow;
}
```

- 单链表的反转

![反转链表](算法\反转链表.png)

```java
//头插法实现链表的逆转
public void reversetList(HeroNode head){
    if (head.next==null||head.next.next==null)
        throw new RuntimeException("链表为空!!!");
    //将原来链表上面的节点依次插到该链表后
    HeroNode revHead = new HeroNode(0, "", "");
    HeroNode temp;
    while (head.next!=null){
        temp = head.next.next;          //temp用来保存与那链表的第二个节点，以防止数据丢失
        head.next.next=revHead.next;    //将原链表的第一个节点的next指向反转链表的第一个节点
        revHead.next = head.next;       //将反转链表的头结点的next指向原链表的第一个节点
        head.next = temp;               //原链表的第一个节点此时已经转移为了反转链表的第一个节点，将原链表的第二个节点作为原链表的第一个节点
    }
    //此处不能head = revHead 因为函数结束之后，revHead作为局部变量会失效
    head.next = revHead.next;
}
```

- 从尾到头打印单链表 

```java
//递归实现逆序打印链表内容
public void reversePrint1(HeroNode head){
    if(head.next == null) {
        return;//空链表，不能打印
    }
    //当head.next指向链表尾节点时递归结束
    if (head.next.next==null)
        System.out.println(head.next);
    else{
        reversePrint1(head.next);
        System.out.println(head.next);
    }
}

//使用栈Stack逆序打印链表内容
public void reversePrint2(HeroNode head){
    if(head.next == null) {
        return;//空链表，不能打印
    }
    //创建要给一个栈，将各个节点压入栈
    Stack<HeroNode> stack = new Stack<HeroNode>();
    HeroNode cur = head.next;
    //将链表的所有节点压入栈
    while(cur != null) {
        stack.push(cur);
        cur = cur.next; //cur 后移，这样就可以压入下一个节点
    }
    //将栈中的节点进行打印,pop 出栈
    while (stack.size() > 0) {
        System.out.println(stack.pop()); //stack 的特点是先进后出
    }
}
```

### 5.3双向链表

**单向链表的缺点分析**: 

- 单向链表，查找的方向只能是一个方向，而双向链表可以向前或者向后查找。 
- 单向链表不能自我删除，需要靠辅助节点 ，而双向链表，则可以自我删除，所以前面我们单链表删除 时节点，总是找到 temp,temp 是待删除节点的前一个节点(认真体会）

**代码实现**

```java
class HeroNode2 {
public int no;
public String name;
public String nickname;
public HeroNode2 next; // 指向下一个节点, 默认为 null
public HeroNode2 pre; // 指向前一个节点, 默认为 null
}
```

### 5.4环形链表-约瑟夫问题

#### 5.4.1约瑟夫问题

Josephu(约瑟夫、约瑟夫环) 问题为：设编号为 1，2，… n 的 n 个人围坐一圈，约定编号为 k（1<=k<=n）的人从 1 开始报数，数 到 m 的那个人出列，它的下一位又从 1 开始报数，数到 m 的那个人又出列，依次类推，直到所有人出列为止，由 此产生一个出队编号的序列。

#### 5.4.2解决思路

用一个不带头结点的循环链表来处理 Josephu 问题：先构成一个有 n 个结点的单循环链表，然后由 k 结点起从 1 开 始计数，计到 m 时，对应结点从链表中删除，然后再从被删除结点的下一个结点又从 1 开始计数，直到最后一个 尚硅谷 Java 数据结构和算法 更多 Java –大数据 –前端 –python 人工智能 -区块链资料下载，可访问百度：尚硅谷官网 第 55页 结点从链表中删除算法结束。

![约瑟夫问题思路分析](算法/约瑟夫问题思路分析.png)

#### 5.4.3代码实现

```java
// 创建一个 Boy 类，表示一个节点
class Boy {
    private int no;// 编号
    private Boy next; // 指向下一个节点,默认 null
}
// 根据用户的输入，计算出小孩出圈的顺序
/**
     *
     * @param startNo
     * 表示从第几个小孩开始数数
     * @param countNum
     * 表示数几下
     * @param nums
     * 表示最初有多少小孩在圈中
     */
public void countBoy(int startNo, int countNum, int nums) {

    if (nums<1||countNum<1||first==null||startNo<1||startNo>nums)
        throw new RuntimeException("参数有误，从新输入！！");
    //创建辅助指针，指向环形链表的最后一个节点
    Boy helper = first;
    while (helper.getNext()!=first){
        helper = helper.getNext();
    }
    //移动helper和first，使从第startNo个小孩开始数
    for (int i=0;i<(startNo-1);i++){
        helper = helper.getNext();
        first = first.getNext();
    }
    //开始数数，出圈
    while (helper!=first){
        //报数
        for (int i=0;i<(countNum-1);i++){
            helper = helper.getNext();
            first = first.getNext();
        }
        System.out.println("小孩"+ first.getNo() +"出队列：" );
        first = first.getNext();
        helper.setNext(first);

    }
    System.out.println("最后的小孩："+ first.getNo());
}
```

## 6.栈

### 6.1栈的介绍

- 栈的英文为(stack) 
- 栈是一个先入后出(FILO-First In Last Out)的有序列表。
- 栈(stack)是限制线性表中元素的插入和删除只能在线性表的同一端进行的一种特殊线性表。允许插入和删除的 一端，为变化的一端，称为栈顶(Top)，另一端为固定的一端，称为栈底(Bottom)。
- 根据栈的定义可知，最先放入栈中元素在栈底，最后放入的元素在栈顶，而删除元素刚好相反，最后放入的元 素最先删除，最先放入的元素最后删除 
- 图解方式说明出栈(pop)和入栈(push)的概念

![栈的介绍](算法/栈的介绍.png)

**应用场景**

1) 子程序的调用：在跳往子程序前，会先将下个指令的地址存到堆栈中，直到子程序执行完后再将地址取出，以回到原来的程序中。 
2) 处理递归调用：和子程序的调用类似，只是除了储存下一个指令的地址外，也将参数、区域变量等数据存入堆栈中。 
3) 表达式的转换[中缀表达式转后缀表达式]与求值(实际解决)。
4) 二叉树的遍历。 
5) 图形的深度优(depth 一 first)搜索法。

### 6.2数组实现栈

##### ![数组模拟栈](算法/数组模拟栈.png)

```java
class ArrayStack{
    private int maxSize;
    private int[] stack;
    private int top;
    public ArrayStack(int maxSize) {
        this.maxSize = maxSize;
        stack = new int[maxSize];
        top = -1;
    }
    public boolean isFull(){return top==maxSize-1;}
    public boolean isEmpty(){return top ==-1;}
    //入栈
    public void push(int value){
        if (isFull())
            throw new RuntimeException("栈满！！！");
        top++;
        stack[top] = value;
    }
    //出栈
    public int pop(){
        if (isEmpty())
            throw new RuntimeException("栈空！！！");
        top--;
        return stack[top+1];
    }
    //从栈顶开始输出栈内的数据
    public void list(){
        for (int i=top;i>=0;i--)
            System.out.printf("stack[%d]=%d\n", i, stack[i]);
    }
}
```

### 6.3栈实现综合计算器(中缀表达式)

![栈实现综合计算器(中缀表达式)](算法/栈实现综合计算器(中缀表达式).png)

**具体代码见 package com.yue.stack.Calculator**

### 6.4前后中缀表达式

- 前缀、中缀、后缀表达式是对表达式的不同记法，其区别在于**运算符相对于操作数的位置不同**，前缀表达式的运算符位于操作数之前，中缀和后缀同理
  - 中缀表达式：1 + (2 + 3) × 4 - 5
  - 前缀表达式：- + 1 × + 2 3 4 5
  - 后缀表达式：1 2 3 + 4 × + 5 -

**前缀表达式**

- 中缀表达式是一种通用的算术或逻辑公式表示方法，操作符以中缀形式处于操作数的中间。中缀表达式是人们常用的算术表示方法。
- 虽然人的大脑很容易理解与分析中缀表达式，但对计算机来说中缀表达式却是很复杂的，因此计算表达式的值时，通常需要先将中缀表达式转换为前缀或后缀表达式，然后再进行求值。**对计算机来说，计算前缀或后缀表达式的值非常简单**。

#### 6.4.1中缀表达式转化为前缀和后缀表达式

1. 按照运算符的优先级对所有的运算单位加括号
2. 将运算符移动到对应括号的前面（前缀表达式）或后面（后缀表达式）
3. 去掉括号，得到前缀或后缀表达式

示例：中缀表达式：1+(2+3)×4-5

1）**加括号**
	式子变成 ((1+((2+3)×4))-5)

2）**移动运算符**

​	对于前缀表达式，变成了 -(+(1×(+(23)4))5)

​	对于后缀表达式：变成了((1((23)+4)×)+5)-

3）**去掉括号**
	前缀表达式： - + 1 × + 2 3 4 5
	后缀表达式：1 2 3 + 4 × + 5 -

### 6.5 逆波兰计算器 

我们完成一个逆波兰计算器，要求完成如下任务: 

- 输入一个逆波兰表达式(后缀表达式)，使用栈(Stack), 计算其结果 
- 支持小括号和多位数整数，因为这里我们主要讲的是数据结构，因此计算器进行简化，只支持对整数的计算。

```java
//完成对逆波兰表达式的运算
/*
1)从左至右扫描，将 3 和 4 压入堆栈；
2)遇到+运算符，因此弹出 4 和 3（4 为栈顶元素，3 为次顶元素），计算出 3+4 的值，得 7，再将 7 入栈；
3)将 5 入栈；
4)接下来是×运算符，因此弹出 5 和 7，计算出 7×5=35，将 35 入栈；
5)将 6 入栈；
6)最后是-运算符，计算出 35-6 的值，即 29，由此得出最终结果
*/
public static int calculate(List<String> ls){
    Stack<String> stack = new Stack();
    for (String item:ls){
        if (item.matches("\\d+")){//使用正则表达式来匹配字符串是否是多位数
            stack.push(item);
        }else {
            //假如不是的话就pop出两个数进行运算，将结果再入栈
            int num2 = Integer.parseInt(stack.pop());
            int num1 = Integer.parseInt(stack.pop());
            int res = 0;
            if (item.equals("+")) {
                res = num1 + num2;
            } else if (item.equals("-")) {
                res = num1 - num2;
            } else if (item.equals("*")) {
                res = num1 * num2;
            } else if (item.equals("/")) {
                res = num1 / num2;
            } else {
                throw new RuntimeException("运算符有误");
            }
            //把 res 入栈
            stack.push("" + res);
        }
    }
    return Integer.parseInt(stack.pop());
}
```

### 6.6 中缀表达式转换为后缀表达式

1) 初始化两个栈：运算符栈 s1 和储存中间结果的栈 s2； 

2) 从左至右扫描中缀表达式； 

3) 遇到操作数时，将其压 s2； 

4) 遇到运算符时，比较其与 s1 栈顶运算符的优先级： 

   ①.如果 s1 为空，或栈顶运算符为左括号“(”，则直接将此运算符入栈； 

   ②.否则，若优先级比栈顶运算符的高，也将运算符压入 s1； 

   ③.否则，将 s1 栈顶的运算符弹出并压入到 s2 中，再次转到(4-1)与 s1 中新的栈顶运算符相比较；

   （弹出优先级大于等于自己的运算符号，直到遇到‘）’或者栈空）

5) 遇到括号时：

   ① 如果是左括号“(”，则直接压入 s1 

   ② 如果是右括号“)”，则依次弹出 s1 栈顶的运算符，并压入 s2，直到遇到左括号为止，此时将这一对括号丢弃 

6) 重复步骤 2 至 5，直到表达式的最右边

7) 将 s1 中剩余的运算符依次弹出并压入 s2 

8) 依次弹出 s2 中的元素并输出，结果的逆序即为中缀表达式对应的后缀表达式

![中缀转后缀](算法/中缀转后缀.png)

```java
//即 ArrayList [1,+,(,(,2,+,3,),*,4,),-,5] =》 ArrayList [1,2,3,+,4,*,+,5,–]
//方法：将得到的中缀表达式对应的 List => 后缀表达式对应的 List
public static List<String> parseSuffixExpreesionList(List<String> ls) {
    //定义两个栈
    Stack<String> s1 = new Stack<String>(); // 符号栈
    //说明：因为 s2 这个栈，在整个转换过程中，没有 pop 操作，而且后面我们还需要逆序输出
    //因此比较麻烦，这里我们就不用 Stack<String> 直接使用 List<String> s2
    //Stack<String> s2 = new Stack<String>(); // 储存中间结果的栈 s2
    List<String> s2 = new ArrayList<String>(); // 储存中间结果的 Lists2
    //遍历 ls
    for(String item: ls) {
        //如果是一个数，加入 s2
        if(item.matches("\\d+")) {
            s2.add(item);
        } else if (item.equals("(")) {
            s1.push(item);
        } else if (item.equals(")")) {
            //如果是右括号“)”，则依次弹出 s1 栈顶的运算符，并压入 s2，直到遇到左括号为止，此时将这一对括号丢弃
            while(!s1.peek().equals("(")) {
                s2.add(s1.pop());
            }
            s1.pop();//!!! 将 ( 弹出 s1 栈， 消除小括号
        } else {
            //当 item 的优先级小于等于 s1 栈顶运算符, 将 s1 栈顶的运算符弹出并加入到 s2 中，再次转到(4.1)与 s1 中新的栈顶运算符相比较
            //问题：我们缺少一个比较优先级高低的方法
            while(s1.size() != 0 && Operation.getValue(s1.peek()) >= Operation.getValue(item) ) {
                s2.add(s1.pop());
            }
            //还需要将 item 压入栈
            s1.push(item);
        }
    }
    //将 s1 中剩余的运算符依次弹出并加入 s2
    while(s1.size() != 0) {
        s2.add(s1.pop());
    }
    return s2; //注意因为是存放到 List, 因此按顺序输出就是对应的后缀表达式对应的 List
}
```

## 7.递归

**递归应用场景**

- 各种数学问题如: 8 皇后问题 , 汉诺塔, 阶乘问题, 迷宫问题, 球和篮子的问题(google 编程大赛) 
- 各种算法中也会使用到递归，比如快排，归并排序，二分查找，分治算法等. 
- 将用栈解决的问题-->第归代码比较简洁

**递归遵守的重要规则**

- 执行一个方法时，就创建一个新的受保护的独立空间(栈空间)
- 方法的局部变量是独立的，不会相互影响, 比如 n 变量
- 如果方法中使用的是引用类型变量(比如数组)，就会共享该引用类型的数据.
- 递归必须向退出递归的条件逼近，否则就是无限递归,出现 StackOverflowError，死龟了:)
- 当一个方法执行完毕，或者遇到 return，就会返回，遵守谁调用，就将结果返回给谁，同时当方法执行完毕或 者返回时，该方法也就执行完毕

### 7.1迷宫问题

使用**递归回溯**来给小球找路 

1. map 表示地图 
2. i,j 表示从地图的哪个位置开始出发 (1,1)
3. 如果小球能到 map[6][5] 位置，则说明通路找到.
4. 约定： 当 map[i][j] 为 0 表示该点没有走过 当为1 表示墙 ；2 表示通路可以走 ；3 表示该点已经走过，但是走不通 
5. 在走迷宫时，需要确定一个策略(方法) 下->右->上->左 , 如果该点走不通，再回溯

```java
/**
 * @param map 表示地图
 * @param i 从哪个位置开始找
 * @param j
 * @return 如果找到通路，就返回 true, 否则返回 false
 */
public static boolean setWay(int[][] map, int i,int j){
    if (map[6][5]==2)   return true;
    if (map[i][j]==0){
        map[i][j]=2;    //假定该点可以走通
        if (setWay(map,i+1,j)) return true;
        else if (setWay(map, i, j+1)) return true;
        else if (setWay(map, i-1, j)) return true;
        else if (setWay(map, i, j-1)) return true;
        else {
            map[i][j]=3;
            return false;
        }
    }else return false;
}
```

### 7.2八皇后问题

- 八皇后问题，是一个古老而著名的问题，是回溯算法的典型案例。该问题是国际西洋棋棋手马克斯·贝瑟尔于 1848 年提出：在 8×8 格的国际象棋上摆放八个皇后，使其不能互相攻击，即：任意两个皇后都不能处于同一行、 同一列或同一斜线上，问有多少种摆法(92)。

![八皇后问题](算法/八皇后问题.png)

```java
	//定义一个 max 表示共有多少个皇后
    int max = 8;
    //定义数组 array, 保存皇后放置位置的结果,比如 arr = {0 , 4, 7, 5, 2, 6, 1, 3}
    int[] arr = new int[max];
//防入第n个皇后
public void check(int n){
    if (n==max) {
        System.out.println(Arrays.toString(arr));
        return;
    }
    //依次放入皇后
    for (int i=0;i<max;i++){
        arr[n]=i;
        if (judge(n)) {//当判断当前皇后与前面的不冲突时，递归到下一层中，开始放下一个皇后
            arr[n]=i;
            check(n+1);
        }
        //当这一层的八个位置放皇后都冲突时，回溯到上一层的for循环中，移动上一个皇后
    }
}
//判断第n个皇后摆放的位置与前面的是否冲突，冲突返回false，不冲突返回true
public boolean judge(int n){
    for (int i=0;i<n;i++){
        //判断与之前的皇后是否冲突
        //Math.abs(n-i)==Math.abs(arr[n]-arr[i])
        //当y-y = x-x时说明为等腰三角形，在同一斜线上
        if (arr[n]==arr[i]||Math.abs(n-i)==Math.abs(arr[n]-arr[i])) 
            return false;
    }
    return true;
}
```

## 8.排序算法

### 8.1排序算法介绍

- 内部排序: 指将需要处理的所有数据都加载到内部存储器(内存)中进行排序。 
- 外部排序法： 数据量过大，无法全部加载到内存中，需要借助外部存储(文件等)进行排序。

![排序算法](算法/排序算法.png)

### 8.2冒泡排序

**冒泡排序**（Bubble Sorting）的基本思想是：通过对待排序序列从前向后（从下标较小的元素开始）,依次比较 相邻元素的值，若发现逆序则交换，使值较大的元素逐渐从前移向后部，就像水底下的气泡一样逐渐向上冒。 

- 优化： 因为排序的过程中，各元素不断接近自己的位置，如果一趟比较下来没有进行过交换，就说明序列有序，因此要在 排序过程中设置一个标志 flag 判断元素是否进行过交换。从而减少不必要的比较。

![冒泡排序](算法/冒泡排序.png)

```java
//冒泡排序
public class BubbleSort {
    public static void main(String[] args) {
        int arr[]={3,9,-1,10,2};
        //提前将len储存好，防止每次for循环都要计算length浪费时间，使用空间换时间
        int len = arr.length;
        //标志位，优化冒泡排序
        boolean flag = false;

        //一共需要冒泡len-1次即可完成排序
        for(int i=0;i<len-1;i++){
            //因为上一次冒泡已经将前i为都固定到了正确的位置上，只需要将泡冒到len-1的位置即可
            for (int j=0;j<len-i-1;j++){
                if (arr[j]>arr[j+1]){
                    int temp = arr[j+1];
                    arr[j+1] = arr[j];
                    arr[j] = temp;
                    flag=true;
                }
            }
            //如果这一趟冒泡中没有发生位置交换，说明此时数组已经排序完成，退出循环即可
            if (!flag) break;
            flag = false;
            System.out.println(Arrays.toString(arr));
        }
    }
}
```

### 8.3选择排序

**选择排序**（select sorting）也是一种简单的排序方法。它的基本思想是：第一次从 arr[0]~arr[n-1]中选取最小值， 与 arr[0]交换，第二次从 arr[1]~arr[n-1]中选取最小值，与 arr[1]交换，第三次从 arr[2]~arr[n-1]中选取最小值，与 arr[2] 交换，…，第 i 次从 arr[i-1]~arr[n-1]中选取最小值，与 arr[i-1]交换，…, 第 n-1 次从 arr[n-2]~arr[n-1]中选取最小值， 与 arr[n-2]交换，总共通过 n-1 次，得到一个按排序码从小到大排列的有序序列

![选择排序](算法/选择排序.png)

```java
public class SelectSort {
    public static void main(String[] args) {
        int arr[]={3,9,-1,10,2};
        //提前将len储存好，防止每次for循环都要计算length浪费时间，使用空间换时间
        int len = arr.length;
        //选择len-1次即可完成排序
        for (int i=0;i<len-1;i++){
            //假如第i个为最大
            int maxIndex = i;
            //将arr[i]与后面的数据依次比较，寻找最小的值的下标
            for (int j=i;j<len;j++)
                if (arr[maxIndex]<arr[j])
                    maxIndex=j;
                //将最小值与第i个值交换位置
            int temp = arr[i];
            arr[i] = arr[maxIndex];
            arr[maxIndex] = temp;
        }
        System.out.println(Arrays.toString(arr));
    }
}
```

### 8.4插入排序

**插入排序**（Insertion Sorting）的基本思想是：把 n 个待排序的元素看成为一个有序表和一个无序表，开始时有 序表中只包含一个元素，无序表中包含有 n-1 个元素，排序过程中每次从无序表中取出第一个元素，把它的排 序码依次与有序表元素的排序码进行比较，将它插入到有序表中的适当位置，使之成为新的有序表。

![插入排序](算法/插入排序.png)

```java
public class InsertSort {
    public static void main(String[] args) {
        int arr[]={3,9,4,5,-2};
        //提前将len储存好，防止每次for循环都要计算length浪费时间，使用空间换时间
        int len = arr.length;

        //第一位只有一位数字，默认为其有序，从第二位开始
        for (int i=1;i<len;i++){
            int temp = arr[i];  //防止后面数组后移时数据丢失，提前创建中间变量储存数组
            int inserIndex = i-1;  //存放要插入的位置下标

            //在前面的有序部分寻找插入位置
            //insertIndex>=0让数组不越界，当inserIndex=-1时说名要将temp插入到0下标位置
            while(inserIndex>=0&&temp<arr[inserIndex]){
                arr[inserIndex+1] = arr[inserIndex];//将数组后移，腾出插入位置
                inserIndex--;
            }
            arr[inserIndex+1] = temp;
        }
        System.out.println(Arrays.toString(arr));
    }
}
```

### 8.4希尔排序

- 希尔排序是希尔（Donald Shell）于 1959 年提出的一种排序算法。希尔排序也是一种插入排序，它是简单插入排序经过改进之后的一个更高效的版本，也称为缩小增量排序。

- 希尔排序是把记录按下标的一定增量分组，对每组使用直接插入排序算法排序；随着增量逐渐减少，每组包含 的关键词越来越多，当增量减至 1 时，整个文件恰被分成一组，算法便终止

  ![希尔排序](算法/希尔排序.png)

```Java
//增强冒泡
public static void shellSort(int[] arr) {
    for (int gap = arr.length / 2; gap > 0; gap /= 2) {
        for (int i = gap; i < arr.length; i++) {
                // 遍历各组中所有的元素(共 gap 组，每组有个元素), 步长 gap
            for (int j = i - gap; j >= 0; j -= gap) {//每一组使用冒泡排序
                // 如果当前元素大于加上步长后的那个元素，说明交换
                if (arr[j] > arr[j + gap]) {
                    int temp = arr[j];
                    arr[j] = arr[j + gap];
                    arr[j + gap] = temp;
                }
            }
        }
    }
}
//增强插入
public static void shellSort2(int[] arr){
    //提前将len储存好，防止每次for循环都要计算length浪费时间，使用空间换时间
    int len = arr.length;
    //gap表示分组的数目
    for (int gap = len/2;gap>0;gap/=2)
        for (int i = gap; i< len; i++){
                int temp = arr[i];
                int j = i;
                while (j-gap>=0&&temp<arr[j-gap]){
                    arr[j] = arr[j-gap];
                    j = j-gap;
                }
                arr[j] = temp;
            }
        }
}
```

### 8.5快速排序

- 快速排序（Quicksort）是对冒泡排序的一种改进。基本思想是：通过一趟排序将要排序的数据分割成独立的两 部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排 序，整个排序过程可以递归进行，以此达到整个数据变成有序序列

![快速排序](算法/快速排序.jpg)

```java
//快速排序
public static void quickSort(int[] arr,int l,int r){
    if (l>=r) return;    //如果数组只有一个数字则退出函数
    int left=l,right=r;
    int pivot = arr[left];  //选择最左边的数字作为中介值
    while (left<right){
        //将右指针逐步向左移动，直到寻找到比中介值小的值，或者右指针移动到和左指针相同
        while (left<right&&arr[right]>=pivot) {
            right--;    //移动指针
        }
        if (left<right)
            arr[left]=arr[right];   //将右指针的值移动到做指针上

        //开始移动左指针，寻找比中介值大的值
        while (left<right&&arr[left]<=pivot){
            left++;     //移动指针
        }
        if (left<right)
            arr[right] = arr[left]; //将左指针的值赋给右指针
    }

    arr[left] = pivot;  //将中介值放到合适的位置
    //System.out.println(Arrays.toString(arr)+"left:"+left+"right:"+right);
    quickSort(arr, l, left-1);  //将中介值左边的部分递归这一过程，由于中介值已经在正确的位置上面了，所以不需要使用left，而是使用left-1，+1
    quickSort(arr, left+1, r);  //将中介值右边的部分递归这一过程
}
```

### 8.6归并排序

- 归并排序（MERGE-SORT）是利用归并的思想实现的排序方法，该算法采用经典的分治（divide-and-conquer） 策略（分治法将问题分(divide)成一些小的问题然后递归求解，而治(conquer)的阶段则将分的阶段得到的各答案"修 补"在一起，即分而治之)

![归并排序-分](算法/归并排序-分.png)

   		再来看看治阶段，我们需要将两个已经有序的子序列合并成一个有序序列，比如上图中的最后一次合并，要将 [4,5,7,8]和[1,2,3,6]两个已经有序的子序列，合并为最终序列[1,2,3,4,5,6,7,8]

![归并排序治](算法/归并排序治.png)

```java
//分+合方法
public static void mergeSort(int[] arr, int left, int right, int[] temp) {
    if(left<right){
        int mid = (left+right)>>1;
        mergeSort(arr, left, mid,temp);
        mergeSort(arr, mid+1, right,temp);
        //分成每个数组只有一个数字时，开始治
        merge(arr, left, mid, right, temp);
    }
}
public static void merge(int[] arr, int left, int mid, int right, int[] temp) {
    int i=left;     //指向左边序列
    int j=mid+1;    //指向右边序列
    int t=0;        //指向中介数组
    //依次将两个有序数组合并到中介数组中，当有一边数组合并完之后推出循环
    while(i<=mid&&j<=right)
        if (arr[i]>arr[j])
            temp[t++] = arr[j++];
        else
            temp[t++] = arr[i++];
    //检查两边数组的数是否都已经放到中介数组中，没有的话将其依次放入
    while (i<=mid)
        temp[t++] = arr[i++];
    while (j<=right)
        temp[t++] = arr[j++];
    //将中介数组的内容拷贝到原数组中
    t=0;
    while (left<=right)
        arr[left++] = temp[t++];
}
```

### 8.7基数排序

- 基数排序（radix sort）属于“分配式排序”（distribution sort），又称“桶子法”（bucket sort）或 bin sort，顾 名思义，它是通过键值的各个位的值，将要排序的元素分配至某些“桶”中，达到排序的作用
- 基数排序法是属于稳定性的排序，基数排序法的是效率高的稳定性排序法
- 基数排序(Radix Sort)是桶排序的扩展
- 基数排序是 1887 年赫尔曼·何乐礼发明的。它是这样实现的：将整数按位数切割成不同的数字，然后按每个 位数分别比较。

将数组 {53, 3, 542, 748, 14, 214} 使用基数排序, 进行升序排序

![基数排序01](算法/基数排序01.png)

![基数排序02](算法/基数排序02.png)

### 8.8堆排序

- 堆排序是利用堆这种数据结构而设计的一种排序算法，堆排序是一种选择排序，它的最坏，最好，平均时间复 杂度均为 O(nlogn)，它也是不稳定排序。
- 堆是具有以下性质的完全二叉树：每个结点的值都大于或等于其左右孩子结点的值，称为大顶堆, 注意 : 没有 要求结点的左孩子的值和右孩子的值的大小关系。
- 每个结点的值都小于或等于其左右孩子结点的值，称为小顶堆
- 大顶堆举例说明

![大顶堆](算法/大顶堆.png)

- 小顶堆举例说明 

![小顶堆](算法/小顶堆.png)

- 一般升序采用大顶堆，降序采用小顶堆

**基本思想**： 

1) 将待排序序列构造成一个大顶堆
2) 此时，整个序列的最大值就是堆顶的根节点。
3) 将其与末尾元素进行交换，此时末尾就为最大值。
4) 然后将剩余 n-1 个元素重新构造成一个堆，这样会得到 n 个元素的次小值。如此反复执行，便能得到一个有序 序列了

图解

**步骤一** 构造初始堆。将给定无序序列构造成一个大顶堆（一般升序采用大顶堆，降序采用小顶堆)。 原始的数组 [4, 6, 8, 5, 9] 

1) .假设给定无序序列结构如下 

![堆排序01](算法/堆排序01.png)

2. 此时我们从最后一个非叶子结点开始（叶结点自然不用调整，第一个非叶子结点 arr.length/2-1=5/2-1=1，也就是下面的 6 结点），从左至右，从下至上进行调整。

![堆排序02](算法/堆排序02.png)

3. 找到第二个非叶节点 4，由于[4,9,8]中 9 元素最大，4 和 9 交换。

![堆排序03](算法/堆排序03.png)

4. 这时，交换导致了子根[4,5,6]结构混乱，继续调整，[4,5,6]中 6 最大，交换 4 和 6。 此时，我们就将一个无序序列构造成了一个大顶堆。 

![堆排序04](算法/堆排序04.png)

**步骤二** 将堆顶元素与末尾元素进行交换，使末尾元素最大。然后继续调整堆，再将堆顶元素与末尾元素交换，得到第二大元素。如此反复进行交换、重建、交换。 

1) .将堆顶元素 9 和末尾元素 4 进行交换 

![堆排序05](算法/堆排序05.png)

2. 重新调整结构，使其继续满足堆定义 

![堆排序06](算法/堆排序06.png)

3. 再将堆顶元素 8 与末尾元素 5 进行交换，得到第二大元素 8

![堆排序07](算法/堆排序07.png)

4. 后续过程，继续进行调整，交换，如此反复进行，最终使得整个序列有序

![堆排序08](算法/堆排序08.png)

**代码实现**

```java
public static void heapSort(int arr[]) {
    //将无序的数组组成一个大顶堆
    //length/2-1表示堆的最后（底层）一个非叶子节点
    for (int i=arr.length/2-1;i>=0;i--) 
        adjustHeap(arr, i,arr.length);

    for(int j = arr.length-1;j>0;j--){
        int temp = arr[j];
        arr[j] = arr[0];
        arr[0] = temp;
        //执行完构建堆的for循之后就不需要每次都从底向上构建了，只需要从根节点开始扫描最大值
        adjustHeap(arr, 0, j);
    }
}
public static void adjustHeap(int arr[], int i, int lenght) {
    int temp = arr[i];
    for (int k = 2*i+1;k<lenght;k=2*k+1){
        if (k<lenght-1&&arr[k]<arr[k+1]) k++;   //比较左右俩个子树的大小，哪个大k取哪个
        if (arr[k]>temp){   //当左右子树大于了父节点时，将子节点赋值给子树
            arr[i]=arr[k];
            i=k;    //将i指向k，因为假如改变子树和其父节点的位置时，可能影响到子节点的子节点的位置，所以要继续循环
        }else {
            break;  //位置合适退出循环即可
        }
    }
    arr[i] = temp;
}
```

### 8.9常用排序算法总结和对比

![排序总结](算法/排序总结.png)



## 9.查找算法

### 9.1二分查找

![二分查找](算法/二分查找.png)

```java
public static int binarySearch(int[] arr, int left, int right, int findVal){
    if (left>right) return -1;
    int mid = (left+right)/2;
    if (findVal>arr[mid])   return binarySearch(arr, mid+1, right, findVal);
    else if (findVal<arr[mid]) return binarySearch(arr, left, mid-1, findVal);
    else return mid;
}
//while循环完成的二分查找
//int mid = left + (right - left) /2;可以防止left+right超出int的范围
//(left+right)>>1==(left+right>>1)/2,但前者比后者运算更快
public static int binarySearchByWhile(int[] arr, int findVal){
    int left=0,right=arr.length-1;
    while (left<= right){
        int mid =(left+right)>>1;
        if (findVal>arr[mid])   left = mid+1;
        else if (findVal<arr[mid])  right = mid-1;
        else return mid;
    }
    return -1;
}
```

### 9.2插值查找

- 插值查找原理介绍: 插值查找算法类似于二分查找，不同的是插值查找每次从自适应 mid 处开始查找。

- 将折半查找中的求 mid 索引的公式 , low 表示左边索引 left, high 表示右边索引 right. key 就是前面我们讲的 findVal 

  ![插值查找公式](算法/插值查找公式.png)

  - int mid = low + (high - low) * (key - arr[low]) / (arr[high] - arr[low]) ;/*插值索引*/ 

  - 对应前面的代码公式： 
  - int mid = left + (right – left) * (findVal – arr[left]) / (arr[right] – arr[left

![插值查找](算法/插值查找.png)

```java
public static int insertValueSearch(int[] arr,int left,int right,int findVal){

    //防止当查找一个特别大的数时数组越界
    if (left>right||findVal>arr[arr.length-1]||findVal<arr[0]) return -1;
    int mid = left + ((findVal-arr[left])/(arr[right]-arr[left]))*(right-left);;
    System.out.println(mid);
    if (findVal>arr[mid])  return insertValueSearch(arr, mid+1, right, findVal);
    else if (findVal<arr[mid]) return insertValueSearch(arr, left, mid-1, findVal);
    else return mid;
}
```

### 9.3斐波那契查找

**将一个长度为F(n)数组看做前后两半，前面一半长度是F(n-1)，后面一半的长度是F(n-1)**。正是这个想法将斐波那契数列和数组联系到一起，也是后面分析的基础：

![斐波那契查找01](算法/斐波那契查找01.png)

其中n的取值是任意长度的，即**对任意长度的数组都能找到对应的斐波那契数**，下面将具体介绍斐波那契查找的步骤。

斐波那契查找的整个过程可以分为：

- 构建斐波那契数列；
- 计算数组长度对应的斐波那契数列元素个数；
- 对数组进行填充；
- 循环进行区间分割，查找中间值；
- 判断中间值和目标值的关系，确定更新策略；

***1.1 构建斐波那契数列\***

这一步骤见前面的文章，构建斐波那契数列如下：

```cpp
[0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377]
```



***1.2 计算数组长度对应的斐波那契数列元素个数\***

假设手中的数据如下：

```cpp
[1, 2, 4, 6, 7, 9, 13,
 16, 17, 21, 23, 25, 27, 
 31, 45, 56, 58, 61, 65, 
 67, 73, 75, 88, 93, 102]
```

可知上述数据共25个元素，不对应1.1节中的斐波那契数列中任何F(n)，这种情况是很常见的。此时，策略是**采用“大于数组长度的最近一个斐波那契数值”**。比如当前数组长度为25，斐波那契数列中大于25的最近元素为34。



***1.3 对数组进行填充\***

确定了斐波那契数值后，就要进行数值填充，即**将数组从25个元素填充到34个**。填充时，将第26到34个元素均采用第25个元素值进行填充，即最大值填充。



***1.4 循环进行区间分割，查找中间值\***

这一个步骤与前面介绍的二分查找和插值查找相似，都是不断的缩小搜索区间，进而确定目标值的位置。区间分割公式如“要点”所述，每次分割中间位置的计算如下：

![img](https://pic4.zhimg.com/80/v2-06f25fa9a8435dfb773b2fd426971cb3_720w.jpg)

此时**数组被分割为左右两个区间，左边区间含有F(n-1)个元素**，-1是因为下标从0开始（比如F(1)表示两个元素）。



***1.5 判断中间值和目标值的关系，确定更新策略\***

中间值和目标值有三种大小关系，分别对应三种处理方式：

- 相等，则查找成功，返回中间位置即可；
- 中间值小于目标值，则说明目标值位于中间值到右边界之间（即右区间），右区间含有F(n-2)个元素，所以n应该更新为n=n-2；
- 中间值大于目标值，这说明目标值位于左边界和中间值之间（即左区间），左区间含有F(n-1)个元素，所以n应更新为n=n-1；

> [斐波那契查找原理——附python和C++实现 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/106883697)

## 10.哈希表

- **散列表**（Hash table，也叫哈希表），是根据关键码值(Key value)而直接进行访问的数据结构。也就是说，它通 过把关键码值映射到表中一个位置来访问记录，以加快查找的速度。这个映射函数叫做散列函数，存放记录的数组 叫做散列表。

**例题**

有一个公司,当有新的员工来报道时,要求将该员工的信息加入(id,性别,年龄,名字,住址..),当输入该员工的 id 时, 要求查找到该员工的 所有信息

![哈希表](算法/哈希表.png)

```java
//编写散列函数, 使用一个简单取模法
public int hashFun(int id) {
   return id % size;
}
```

## 11.树结构

### 11.1为什么需要树这种数据结构

1) 数组存储方式的分析 优点：通过下标方式访问元素，速度快。对于有序数组，还可使用二分查找提高检索速度。 缺点：如果要检索具体某个值，或者插入值(按一定顺序)会整体移动，效率较低

![数组特点](算法/数组特点.png)

2) 链式存储方式的分析 优点：在一定程度上对数组存储方式有优化(比如：插入一个数值节点，只需要将插入节点，链接到链表中即可， 删除效率也很好)。 缺点：在进行检索时，效率仍然较低，比如(检索某个值，需要从头节点开始遍历) 

![链表特点](算法/链表特点.png)

3) 树存储方式的分析 能提高数据存储，读取的效率, 比如利用 二叉排序树(Binary Sort Tree)，既可以保证数据的检索速度，同时也 可以保证数据的插入，删除，修改的速度。

![树特点](算法/树特点.png)

### 11.2树的常用术语

树的常用术语(结合示意图理解): 

- 节点 
- 根节点
- 父节点 
- 子节点 
- 叶子节点 (没有子节点的节点)
- 节点的权(节点值) 
- 路径(从 root 节点找到该节点的路线) 
- 层 
- 子树
- 树的高度(最大层数) 
- 森林 :多颗子树构成森林

![树的专用术语](算法/树的专用术语.png)

### 11.3二叉树

- 树有很多种，每个节点最多只能有两个子节点的一种形式称为二叉树。 

- 二叉树的子节点分为左节点和右节点

![二叉树](算法/二叉树.png)

- 如果该二叉树的所有叶子节点都在最后一层，并且结点总数= 2^n -1 , n 为层数，则我们称为**满二叉树**

![满二叉树](算法/满二叉树.png)

- 如果该二叉树的所有叶子节点都在最后一层或者倒数第二层，而且最后一层的叶子节点在左边连续，倒数第二 层的叶子节点在右边连续，我们称为**完全二叉树**

![完全二叉树](算法/完全二叉树.png)

#### 11.3.2二叉树-遍历

前序遍历: 先输出父节点，再遍历左子树和右子树 

中序遍历: 先遍历左子树，再输出父节点，再遍历右子树 

后序遍历: 先遍历左子树，再遍历右子树，最后输出父节点

![二叉树的遍历](算法/二叉树的遍历.png)

```java
//树的节点
class HeroNode{
    private int no;
    private String name;
    private HeroNode left;  //左右节点
    private HeroNode right;
}
//前序遍历
public void preOrder(HeroNode node){
    if (node == null) throw new RuntimeException("树为空！！！");
    System.out.println(node.getNo());
    if (node.getLeft()!=null) preOrder(node.getLeft());
    if (node.getRight()!=null) preOrder(node.getRight());
}
//中序遍历
public void infixOrder(HeroNode node){
    if (node == null) throw new RuntimeException("树为空！！！");
    if (node.getLeft()!=null) infixOrder(node.getLeft());
    System.out.println(node.getNo());
    if (node.getRight()!=null) infixOrder(node.getRight());
}
//后序遍历
public void postOrder(HeroNode node){
    if (node == null) throw new RuntimeException("树为空！！！");
    if (node.getLeft()!=null) postOrder(node.getLeft());
    if (node.getRight()!=null) postOrder(node.getRight());
    System.out.println(node.getNo());
}
```

#### 11.3.3二叉树-查找指定节点

![二叉树查找](算法/二叉树查找.png)



```java
//前序遍历查找
public HeroNode preOrderSearch(HeroNode node,int no){
    if (node == null) throw new RuntimeException("树为空！！！");
    HeroNode resNode = null;    //假如查找到节点就放到resNode中，以方便判断递归的停止
    if (node.getNo()==no) return node;
    if (node.getLeft()!=null) resNode = preOrderSearch(node.getLeft(),no);
    if (resNode!=null) return resNode;  //在左分支上面查找到结果的话就结束递归，不在进入右分支
    if (node.getRight()!=null)resNode = preOrderSearch(node.getRight(),no);
    if (resNode!=null) return resNode;
    return null;
}
```



#### 11.3.4二叉树-删除指定节点

![二叉树删除节点](算法/二叉树删除节点.png)

```java
//Tree
public void delNode(int no){
    if (root == null) throw new RuntimeException("树为空！！！");
    if (root.getNo() == no) root=null;
    else root.delNode(no);
}
//Node
public void delNode(int no){
    if (this.left!=null){
        if (this.left.getNo()==no){
            this.left=null;
        }else
            this.left.delNode(no);
    }
    if (this.right!=null){
        if (this.right.getNo()==no){
            this.right=null;
        }else
            this.right.delNode(no);
    }

}
```

### 11.4顺序存储二叉树

- 从数据存储来看，数组存储方式和树的存储方式可以相互转换，即数组可以转换成树，树也可以转换成数组， 看右面的示意图

![顺序存储二叉树](算法/顺序存储二叉树.png)

#### 11.4.1顺序存储二叉树的特点

- 顺序二叉树通常只考虑完全二叉树
- 第 n 个元素的左子节点为 2 * n + 1
- 第 n 个元素的右子节点为 2 * n + 2
- 第 n 个元素的父节点为 (n-1) / 2 
- n : 表示二叉树中的第几个元素

**顺序存储二叉树前序遍历**

```java
public void preOrder(int index){

    if (arr==null||arr.length==0) 
        throw new RuntimeException("树为空！！！");
    System.out.println(arr[index]);
    if (2*index+1<arr.length) preOrder(2*index+1);
    if (2*index+2<arr.length) preOrder(2*index+2);
}
```

### 11.5线索化二叉树

#### 11.5.1常规二叉树的问题

将数列 {1, 3, 6, 8, 10, 14 } 构建成一颗二叉树. n+1=7

![常规二叉树的问题](算法/常规二叉树的问题.png)

**问题分析:** 

1) 当我们对上面的二叉树进行中序遍历时，数列为 {8, 3, 10, 1, 6, 14 }
2) 但是 6, 8, 10, 14 这几个节点的 左右指针，并没有完全的利用上.
3) 如果我们希望充分的利用 各个节点的左右指针， 让各个节点可以指向自己的前后节点,怎么办? 
4) 解决方案-线索二叉树

#### 11.5.2线索二叉树

- n 个结点的二叉链表中含有 n+1 【公式 2n-(n-1)=n+1】 个空指针域。利用二叉链表中的空指针域，存放指向 该结点在某种遍历次序下的前驱和后继结点的指针（这种附加的指针称为"线索"）
- 这种加上了线索的二叉链表称为线索链表，相应的二叉树称为线索二叉树(Threaded BinaryTree)。根据线索性质 的不同，线索二叉树可分为前序线索二叉树、中序线索二叉树和后序线索二叉树三种
- 一个结点的前一个结点，称为前驱结点
- 一个结点的后一个结点，称为后继结点

![线索二叉树](算法/线索二叉树.png)

说明: 当线索化二叉树后，Node 节点的 属性 left 和 right ，有如下情况:

- left 指向的是左子树，也可能是指向的前驱节点. 比如 ① 节点 left 指向的左子树, 而 ⑩ 节点的 left 指向的 就是前驱节点. 

- right 指向的是右子树，也可能是指向后继节点，比如 ① 节点 right 指向的是右子树，而⑩ 节点的 right 指向 的是后继节点

**代码实现**

```java
//树的节点
class HeroNode{
    private int no;
    private String name;
    private HeroNode left;  //左右节点
    private HeroNode right;
    //标记左节点是否指向前驱节点，1指向前驱节点，指向左节点
    private int leftTag=0;    
    //标记右节点是否指向后继节点，1指向后继节点，指向右节点
    private int rightTag=0;   
}
//中序遍历线索二叉树
    public void threadedNodes(HeroNode node){
        if (node==null) return;
        if (node.getLeft()!=null) threadedNodes(node.getLeft());
        if (node.getLeft()==null){
            node.setLeft(pre);
            node.setLeftTag(1);
        }
        if (pre!=null&&pre.getRight()==null){
            pre.setRight(node);
            System.out.println(node);
            pre.setRightTag(1);
        }
        //当左子树遍历完之后，将左子树设置为前驱节点
        pre = node;
        if (node.getRight()!=null) threadedNodes(node.getRight());
    }
```

#### 11.5.3遍历线索化二叉树

- 因为线索化后，各个结点指向有变化，因此原来的遍历方式不能使用，这时需要使用新的方式遍历 线索化二叉树，各个节点可以通过线型方式遍历，因此无需使用递归方式，这样也提高了遍历的效率。 遍历的次 序应当和中序遍历保持一致。

```java
/遍历线索化二叉树的方法
public void threadedList(){
    HeroNode node = root;
    if (node==null) return;
    while (node!=null){
        //循环的找到 leftType == 1 的结点，第一个找到就是 8 结点
        //后面随着遍历而变化,因为当 leftType==1 时，说明该结点是按照线索化
        //处理后的有效结点
        while (node.getLeftTag()==0)
            node = node.getLeft();
        System.out.println(node);
        while (node.getRightTag()==1){
            node = node.getRight();
            System.out.println(node);
        }
        node = node.getRight();
    }
```

## 12.树结构的实际应用

### 12.1堆排序

**见8.8堆排序**

### 12.2赫夫曼树

- 给定 n 个权值作为 n 个叶子结点，构造一棵二叉树，**若该树的带权路径长度(wpl)达到最小**，称这样的二叉树为 最优二叉树，也称为哈夫曼树(Huffman Tree), 还有的书翻译为霍夫曼树。 
- 赫夫曼树是带权路径长度最短的树，权值较大的结点离根较近

#### 12.2.1赫夫曼树的几个重要概念

- **路径和路径长度：**在一棵树中，从一个结点往下可以达到的孩子或孙子结点之间的通路，称为路径。通路中分支的数目称为路径长度。若规定根结点的层数为 1，则从根结点到第 L 层结点的路径长度为 L-1
- **结点的权及带权路径长度：**若将树中结点赋给一个有着某种含义的数值，则这个数值称为该结点的权。结 点的带权路径长度为：从根结点到该结点之间的路径长度与该结点的权的乘积
- **树的带权路径长度：**树的带权路径长度规定为所有叶子结点的带权路径长度之和，记为 **WPL**(weighted path length) ,权值越大的结点离根结点越近的二叉树才是最优二叉树。
- WPL 最小的就是赫夫曼树
- ![wpl](算法/wpl.png)

#### 12.2.2构成赫夫曼树的步骤

1) 从小到大进行排序, 将每一个数据，每个数据都是一个节点 ， 每个节点可以看成是一颗最简单的二叉树
2) 取出根节点权值最小的两颗二叉树
3) 组成一颗新的二叉树, 该新的二叉树的根节点的权值是前面两颗二叉树根节点权值的和 
4) 再将这颗新的二叉树，以根节点的权值大小 再次排序， 不断重复 1-2-3-4 的步骤，直到数列中，所有的数 据都被处理，就得到一颗赫夫曼树
5) 图解

![赫夫曼树的构建](算法/赫夫曼树的构建.png)



**代码实现**

```java
//用数组创建哈夫曼树
public static Node createHuffmanTree(int arr[]){
    List<Node> nodeList = new ArrayList<>();
    for (int val:arr)
        nodeList.add(new Node(val));

    //不断地挑选出数组中最小的两个组成一个新的树
    while (nodeList.size()>1){
        //排序之后0，1就是权值最小的两个结点
        Collections.sort(nodeList);
        Node leftNode = nodeList.get(0);
        Node rightNode = nodeList.get(1);

        //将0，1移除，将组成的新的树的结点放入数组
        Node newNode = new Node(leftNode.getVal() + rightNode.getVal());
        newNode.setLeft(leftNode);
        newNode.setRight(rightNode);
        nodeList.remove(leftNode);
        nodeList.remove(rightNode);
        nodeList.add(newNode);
    }
    //最后剩下的一个结点即为哈夫曼树的根节点
    return nodeList.get(0);
}
```

### 12.3赫夫曼编码

- 赫夫曼编码也翻译为 哈夫曼编码(Huffman Coding)，又称霍夫曼编码，是一种编码方式, 属于一种程序算法
- 赫夫曼编码是赫哈夫曼树在电讯通信中的经典的应用之一。
- 赫夫曼编码广泛地用于数据文件压缩。其压缩率通常在 20%～90%之间
- 赫夫曼码是可变字长编码(VLC)的一种。Huffman 于 1952 年提出一种编码方法，称之为最佳编码

**步骤：**

传输的字符串 

1) i like like like java do you like a java 

2) d:1 y:1 u:1 j:2 v:2 o:2 l:4 k:4 e:4 i:5 a:5 :9 // 各个字符对应的个数 

3) 按照上面字符出现的次数构建一颗赫夫曼树, 次数作为权值 

4) 步骤： 构成赫夫曼树的步骤： 

   - 从小到大进行排序, 将每一个数据，每个数据都是一个节点 ， 每个节点可以看成是一颗最简单的二叉树
   - 取出根节点权值最小的两颗二叉树
   - 组成一颗新的二叉树, 该新的二叉树的根节点的权值是前面两颗二叉树根节点权值的和
   - 再将这颗新的二叉树，以根节点的权值大小 再次排序， 不断重复 1-2-3-4 的步骤，直到数列中，所有的数据都被处理， 就得到一颗赫夫曼树

   ![赫夫曼树构建](算法/赫夫曼树构建.png)

5) 根据赫夫曼树，给各个字符,规定编码 (前缀编码)， 向左的路径为 0 向右的路径为 1 ， 编码 如下: o: 1000 u: 10010 d: 100110 y: 100111 i: 101 a : 110 k: 1110 e: 1111 j: 0000 v: 0001 l: 001 : 01

6) 按照上面的赫夫曼编码，我们的"i like like like java do you like a java" 字符串对应的编码为 (注 意这里我们使用的无损压缩) 1010100110111101111010011011110111101001101111011110100001100001110011001111000011001111000100100100110111101111011100100001100001110 通过赫夫曼编码处理长度为 133 

7) 长度为 ： 133 说明: 原来长度是 359 , 压缩了 (359-133) / 359 = 62.9% 

   此编码满足前缀编码, 即字符的编码都不能是其他字符编码的前缀。不会造成匹配的多义性 赫夫曼编码是无损处理方案

**注意事项：** 这个赫夫曼树根据排序方法不同，也可能不太一样，这样对应的赫夫曼编码也不完全一样，但是 wpl 是 一样的，都是最小的, 最后生成的赫夫曼编码的长度是一样，比如: 如果我们让每次生成的新的二叉树总是排在权 值相同的二叉树的最后一个，则生成的二叉树为:

![赫夫曼树的不同构建](算法/赫夫曼树的不同构建.png)



### 12.4二叉排序树

- 二叉排序树：BST: (Binary Sort(Search) Tree), 对于二叉排序树的任何一个非叶子节点，要求左子节点的值比当 前节点的值小，右子节点的值比当前节点的值大

![二叉排序树概念](算法/二叉排序树概念.png)

#### 12.4.1二叉树的创建遍历

一个数组创建成对应的二叉排序树，并使用中序遍历二叉排序树，比如: 数组为 Array(7, 3, 10, 12, 5, 1, 9) ， 创 建成对应的二叉排序树为 

![二叉树的创建](算法/二叉树的创建.png)

#### 12.4.1二叉排序树的删除

![二叉排序树的删除](算法/二叉排序树的删除.png)

二叉排序树的删除情况比较复杂，有下面三种情况需要考虑

	- 删除叶子节点 (比如：2, 5, 9, 12)
	- 删除只有一颗子树的节点 (比如：1) 
	- 删除有两颗子树的节点. (比如：7, 3，10 ) 4) 

第一种情况: 删除叶子节点 (比如：2, 5, 9, 12) 

- (1) 需求先去找到要删除的结点 targetNode 

- (2) 找到 targetNode 的 父结点 parent 

- (3) 确定 targetNode 是 parent 的左子结点 还是右子结点

- (4) 根据前面的情况来对应删除 左子结点 parent.left = null 右子结点 parent.right = null; 

第二种情况: 删除只有一颗子树的节点 比如 1 

- (1) 需求先去找到要删除的结点 targetNode 
- (2) 找到 targetNode 的 父结点 parent 
- (3) 确定 targetNode 的子结点是左子结点还是右子结点 
- (4) targetNode 是 parent 的左子结点还是右子结点 
- (5) 如果 targetNode 有左子结点 
  - 如果 targetNode 是 parent 的左子结点parent.left = targetNode.left; 
  - 如果 targetNode 是 parent 的右子结点 parent.right = targetNode.left; 
- 如果 targetNode 有右子结点 
  - 如果 targetNode 是 parent 的左子结点 parent.left = targetNode.right; 
  - 如果 targetNode 是 parent 的右子结点 parent.right = targetNode.right 

情况三 ： 删除有两颗子树的节点. (比如：7, 3，10 ) 

- (1) 需求先去找到要删除的结点 targetNode
- (2) 找到 targetNode 的 父结点 parent 
- (3) 从 targetNode 的右子树找到最小的结点 
- (4) 用一个临时变量，将 最小结点的值保存 temp = 11 
- (5) 删除该最小结点 
- (6) targetNode.value = tem



## 13.多路查找树

## 14.图

图是一种数据结构，其中结点可以具有零个或多个相邻元素。两个结点之间的连接称为边。 结点也可以称为 顶点。

### 14.1图的常用概念

顶点(vertex)  边(edge)   路径  无向图

![无向图](算法/无向图.png)

![有向图带权图](算法/有向图带权图.png)



### 14.2图的表示方式

**邻接矩阵**

- 邻接矩阵是表示图形中顶点之间相邻关系的矩阵，对于 n 个顶点的图而言，矩阵是的 row 和 col 表示的是 1....n 个点。

![邻接矩阵](算法/邻接矩阵.png)

**邻接表**

- 邻接矩阵需要为每个顶点都分配 n 个边的空间，其实有很多边都是不存在,会造成空间的一定损失. 

- 邻接表的实现只关心存在

![邻接表](算法/邻接表.png)



**常用功能代码实现**

```java
public class Graph {
    //构造器，vertexNum顶点个数
    public Graph(int vertexNum){
        vertexList = new ArrayList<>(vertexNum);
        edges = new int[vertexNum][vertexNum];
        numOfEdges = 0;
    }

    private ArrayList<String> vertexList;   //存储顶点集合
    private int[][] edges;  //存储图对应的邻接矩阵
    private int numOfEdges; //存放边的数目

    //定义给数组 boolean[], 记录某个结点是否被访问
    private boolean[] isVisited;

    //获取顶点个数
    public int getNumOfVertex(){
        return vertexList.size();
    }
    //显示图对应的邻接矩阵
    public void showGraph(){
        System.out.println(Arrays.deepToString(edges));
    }
    //获得边的个数
    public int getNumOfEdges() {
        return numOfEdges;
    }
    //返回结点 i(下标)对应的数据 0->"A" 1->"B" 2->"C"
    public String getValueByIndex(int i) {
        return vertexList.get(i);
    }
    //返回v1和v2的权值
    public int getWeight(int v1,int v2){
        return edges[v1][v2];
    }
    //添加结点
    public void insertVertex(String vertex){
        vertexList.add(vertex);
    }
    //添加边
    // @param v1 表示点的下标即使第几个顶点 "A"-"B" "A"->0 "B"->1
    //* @param v2 第二个顶点对应的下标
    //* @param weight 表示
    public void insertEdge(int v1,int v2,int weight){
        edges[v1][v2] = weight;
        edges[v2][v1] = weight;
        numOfEdges++;
    }
    
}
```

**创建图**

```java
public static void main(String[] args) {
    int n = 5; //结点的个数
    String Vertexs[] = {"A", "B", "C", "D", "E"};
    //String Vertexs[] = {"1", "2", "3", "4", "5", "6", "7", "8"}
    Graph graph = new Graph(n);
    for(String vertex: Vertexs) {
        graph.insertVertex(vertex);
    }
    //添加边 A-B A-C B-C B-D B-E
    graph.insertEdge(0, 1, 1); // A-B
    graph.insertEdge(0, 2, 1); //
    graph.insertEdge(1, 2, 1); //
    graph.insertEdge(1, 3, 1); //
    graph.insertEdge(1, 4, 1); //
    graph.showGraph();
}
```

### 14.3图的深度遍历



### 14.4图的广度遍历

## 程序员常用算法

### 动态规划

1) 动态规划(Dynamic Programming)算法的核心思想是：将大问题划分为小问题进行解决，从而一步步获取最优解 的处理算法 

2) 动态规划算法与分治算法类似，其基本思想也是将待求解问题分解成若干个子问题，先求解子问题，然后从这 些子问题的解得到原问题的解。 

3) 与分治法不同的是，适合于用动态规划求解的问题，经分解得到子问题往往不是互相独立的。 ( 即下一个子 阶段的求解是建立在上一个子阶段的解的基础上，进行进一步的求解

4) 动态规划可以通过填表的方式来逐步推进，得到最优解.

   #### 背包问题

   背包问题：有一个背包，容量为 4 磅 ， 现有如下物品

   | 物品 | 重量 | 价格 |
   | ---- | ---- | ---- |
   | 吉他 | 1    | 1500 |
   | 音响 | 4    | 3000 |
   | 电脑 | 3    | 2000 |

   1. 要求达到的目标为装入的背包的总价值最大，并且重量不超出

   2. 要求装入的物品不能重复 

   3. 背包问题主要是指一个给定容量的背包、若干具有一定价值和重量的物品，如何选择物品放入背包使物品的价 值最大。其中又分 01 背包和完全背包(完全背包指的是：每种物品都有无限件可用) 

   4. 这里的问题属于 01 背包，即每个物品最多放一个。而无限背包可以转化为 01 背包。 

   5. 算法的主要思想，利用动态规划来解决。每次遍历到的第 i 个物品，根据 w[i]和 v[i]来确定是否需要将该物品 放入背包中。即对于给定的 n 个物品，设 v[i]、w[i]分别为第 i 个物品的价值和重量，C 为背包的容量。再令 v[i][j] 表示在前 i 个物品中能够装入容量为 j 的背包中的最大价值。则我们有下面的结果：

      (1) v[i][0]=v[0][j]=0; //表示 填入表 第一行和第一列是 0

      (2) 当 w[i]> j 时：v[i][j]=v[i-1][j] // 当准备加入新增的商品的容量大于 当前背包的容量时，就直接使用上一个 单元格的装入策略 

      (3) 当 j>=w[i]时： v[i][j]=max{v[i-1][j], v[i]+v[i-1][j-w[i]]} 

      // 当 准备加入的新增的商品的容量小于等于当前背包的容量, 

      // 装入的方式:

      ​	 v[i-1][j]： 就是上一个单元格的装入的最大值 

      ​	v[i] : 表示当前商品的价值 

      ​	v[i-1][j-w[i]] ： 装入 i-1 商品，到剩余空间 j-w[i]的最大值 

      ​	当 j>=w[i]时： v[i][j]=max{v[i-1][j], v[i]+v[i-1][j-w[i]]} 

   ![背包问题](算法/背包问题.png)

```java
//动态规划解决背包问题
public class KnapsackProblem {
    public static void main(String[] args) {
        int[] w = {1, 4, 3};//物品的重量
        int[] val = {1500, 3000, 2000}; //物品的价值 这里 val[i] 就是前面讲的 v[i]
        int m = 4; //背包的容量
        int n = val.length;//物品的个数

        //创建二维数组，
        //v[i][j] 表示在前 i 个物品中能够装入容量为 j 的背包中的最大价值
        int[][] v = new int[n+1][m+1];

        //为了记录放入商品的情况，我们定一个二维数组
        int[][] path =new int[n+1][m+1];

        //处理第一行，第一列都设置为0
        for(int i=0;i<v.length;i++) v[i][0]=0;
        for(int i=0;i<v[0].length;i++) v[0][i]=0;

        //当 w[i]> j 时：v[i][j]=v[i-1][j] //当准备加入新增的商品的容量大于当前背包的容量时，就直接使用上一个单元格的装入策略
        //当 j>=w[i]时： v[i][j]=max{v[i-1][j], val[i]+v[i-1][j-w[i]]}
        //j是横行，i是竖行(i-1表示当前是哪个商品)
        for (int i =1;i<v.length;i++){
            for (int j=1;j<v[0].length;j++){
                if (w[i-1]>j) v[i][j]=v[i-1][j];
                else v[i][j]=Math.max(v[i-1][j],val[i-1]+v[i-1][j-w[i-1]]);
            }
        }
        //输出一下 v 看看目前的情况
        for(int i =0; i < v.length;i++) {
            for(int j = 0; j < v[i].length;j++) {
                System.out.print(v[i][j] + " ");
            }
            System.out.println();
        }
    }
}
```

### 贪心算法

- 贪婪算法(贪心算法)是指在对问题进行求解时，在每一步选择中都采取最好或者最优(即最有利)的选择，从而 希望能够导致结果是最好或者最优的算法 
- 贪婪算法所得到的结果不一定是最优的结果(有时候会是最优解)，但是都是相对近似(接近)最优解的结果

#### 应用场景-集合覆盖问题

假设存在下面需要付费的广播台，以及广播台信号可以覆盖的地区。 如何选择最少的广播台，让所有的地区 都可以接收到信号

![广播问题](算法/广播问题.png)

**思路分析**

如何找出覆盖所有地区的广播台的集合呢，使用穷举法实现,列出每个可能的广播台的集合，这被称为幂集。假设总的有 n 个广播台，则广播台的组合总共2ⁿ -1 个，显然不太现实

使用**贪婪算法**，效率高: 

1. 目前并没有算法可以快速计算得到准备的值， 使用贪婪算法，则可以得到非常接近的解，并且效率高。选择 策略上，因为需要覆盖全部地区的最小集合: 

2. 遍历所有的广播电台, 找到一个覆盖了最多未覆盖的地区的电台(此电台可能包含一些已覆盖的地区，但没有关 系） 
3. 将这个电台加入到一个集合中(比如 ArrayList), 想办法把该电台覆盖的地区在下次比较时去掉。 
4. 重复第 1 步直到覆盖了全部的地

```java
//创建 ArrayList, 存放选择的电台集合
ArrayList<String> selects = new ArrayList<String>();
//定义一个临时的集合， 在遍历的过程中，存放遍历过程中的电台覆盖的地区和当前还没有覆盖的地区的交集
HashSet<String> tempSet = new HashSet<String>();
//定义给 maxKey ， 保存在一次遍历过程中，能够覆盖最大未覆盖的地区对应的电台的 key
//如果 maxKey 不为 null , 则会加入到 selects
String maxKey = null;
while (allAreas.size()>0){
    for(String key:broadcasts.keySet()){
        tempSet.clear();
        HashSet<String> area = broadcasts.get(key);
        tempSet.addAll(area);
        tempSet.retainAll(allAreas);
        if (maxKey!=null) broadcasts.get(maxKey).retainAll(allAreas);
        if (tempSet.size()>0&&(maxKey==null||tempSet.size()>broadcasts.get(maxKey).size())){
            maxKey = key;
        }
    }
    if(maxKey != null) {
        selects.add(maxKey);
        //将 maxKey 指向的广播电台覆盖的地区，从 allAreas 去掉
        allAreas.removeAll(broadcasts.get(maxKey));
    }
}
System.out.println("得到的选择结果是" + selects);//[K1,K2,K3,K5]
```
